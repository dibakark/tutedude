# -*- coding: utf-8 -*-
"""Module 9 - Maths for DS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IepiRrBmlgRZsUNuJDSMTVTXmLShpYZ_

1. Matrix and Vector Operations


1. Create a 3 × 3 matrix A and a 3 × 1 vector B :


   import numpy as np
   A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
   B = np.array([1, 2, 3])


   Tasks -
   - Perform matrix-vector multiplication  A X B.
   - Calculate the trace of matrix  A  (sum of diagonal elements).
   - Find the eigenvalues and eigenvectors of A.


2. Replace the last row of matrix A with [10, 11, 12] and:
   - Compute the determinant of the updated matrix A.
   - Identify if the updated matrix is singular or non-singular.
"""

import numpy as np

# Define the 3x3 matrix A and 3x1 vector B
A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
B = np.array([1, 2, 3])

# Perform matrix-vector multiplication
AxB = np.dot(A, B)
print("Matrix-Vector Multiplication (A x B):\n", AxB)

# Calculate the trace of matrix A
trace_A = np.trace(A)
print("Trace of matrix A:", trace_A)

# Find eigenvalues and eigenvectors of A
eigenvalues, eigenvectors = np.linalg.eig(A)
print("Eigenvalues of A:", eigenvalues)
print("Eigenvectors of A:\n", eigenvectors)

# Update the last row of A
A[2] = [10, 11, 12]
print("Updated Matrix A:\n", A)

# Compute the determinant of the updated matrix
det_A = np.linalg.det(A)
print("Determinant of updated A:", det_A)

# Check if the updated matrix is singular or non-singular
if np.isclose(det_A, 0):
    print("The updated matrix is singular (non-invertible).")
else:
    print("The updated matrix is non-singular (invertible).")

"""2. Invertibility of Matrices


1. Verify the invertibility of the updated matrix A:
   - Check if the determinant is non-zero.
   - If invertible, calculate the inverse of A.


2. Solve a system of linear equations A x X = B, where:
   - A is the updated matrix.

"""

import numpy as np

# Define the 3x3 matrix A and 3x1 vector B
A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
B = np.array([1, 2, 3])

# Perform matrix-vector multiplication
AxB = np.dot(A, B)
print("Matrix-Vector Multiplication (A x B):\n", AxB)

# Calculate the trace of matrix A
trace_A = np.trace(A)
print("Trace of matrix A:", trace_A)

# Find eigenvalues and eigenvectors of A
eigenvalues, eigenvectors = np.linalg.eig(A)
print("Eigenvalues of A:", eigenvalues)
print("Eigenvectors of A:\n", eigenvectors)

# Update the last row of A
A[2] = [10, 11, 12]
print("Updated Matrix A:\n", A)

# Compute the determinant of the updated matrix
det_A = np.linalg.det(A)
print("Determinant of updated A:", det_A)

# Check if the updated matrix is singular or non-singular
if np.isclose(det_A, 0):
    print("The updated matrix is singular (non-invertible).")
else:
    print("The updated matrix is non-singular (invertible).")

    # Compute the inverse of A if it is invertible
    A_inv = np.linalg.inv(A)
    print("Inverse of updated A:\n", A_inv)

    # Solve the system of linear equations A * X = B
    X = np.linalg.solve(A, B)
    print("Solution X for A * X = B:\n", X)

"""3. Practical Matrix Operations


1. Create a 4 × 4 matrix C with random integers between 1 and 20:
  
   C = np.random.randint(1, 21, size=(4, 4))


   Tasks
   - Compute the rank of C.
   - Extract the submatrix consisting of the first 2 rows and last 2 columns of C.
   - Calculate the Frobenius norm of C.


2. Perform matrix multiplication between A (updated to 3 × 3) and C (trimmed to 3 × 3):
   - Check if the multiplication is valid. If not, reshape C to make it compatible with A.

"""

# Create a 4x4 matrix C with random integers between 1 and 20
C = np.random.randint(1, 21, size=(4, 4))
print("Matrix C:\n", C)

# Compute the rank of C
rank_C = np.linalg.matrix_rank(C)
print("Rank of C:", rank_C)

# Extract the submatrix consisting of the first 2 rows and last 2 columns
submatrix_C = C[:2, -2:]
print("Submatrix (first 2 rows, last 2 columns):\n", submatrix_C)

# Calculate the Frobenius norm of C
frobenius_norm_C = np.linalg.norm(C, 'fro')
print("Frobenius norm of C:", frobenius_norm_C)

# Trim C to 3x3 for matrix multiplication with A
C_trimmed = C[:3, :3]

# Perform matrix multiplication between A and trimmed C if valid
if A.shape[1] == C_trimmed.shape[0]:
    AC_product = np.dot(A, C_trimmed)
    print("Matrix Multiplication (A x C_trimmed):\n", AC_product)
else:
    print("Matrix multiplication is not valid due to shape mismatch.")

"""4. Data Science Context


1. Create a dataset as a 5 × 5 matrix D, where each column represents a feature, and each row represents a data point:


   D = np.array([[3, 5, 7, 9, 11],
                 [2, 4, 6, 8, 10],
                 [1, 3, 5, 7, 9],
                 [4, 6, 8, 10, 12],
                 [5, 7, 9, 11, 13]])


   Tasks
   - Standardize D column-wise (mean = 0, variance = 1).
   - Compute the covariance matrix of D.
   - Perform Principal Component Analysis (PCA):
     - Find the eigenvalues and eigenvectors of the covariance matrix.
     - Reduce D to 2 principal components.
"""

# Create a 5x5 dataset matrix D
D = np.array([[3, 5, 7, 9, 11],
              [2, 4, 6, 8, 10],
              [1, 3, 5, 7, 9],
              [4, 6, 8, 10, 12],
              [5, 7, 9, 11, 13]])
print("Dataset Matrix D:\n", D)

# Standardize D column-wise (mean = 0, variance = 1)
D_mean = np.mean(D, axis=0)
D_std = np.std(D, axis=0)
D_standardized = (D - D_mean) / D_std
print("Standardized D:\n", D_standardized)

# Compute the covariance matrix of D
cov_matrix_D = np.cov(D_standardized, rowvar=False)
print("Covariance Matrix of D:\n", cov_matrix_D)

# Perform PCA: Find eigenvalues and eigenvectors
eigenvalues_D, eigenvectors_D = np.linalg.eig(cov_matrix_D)
print("Eigenvalues of Covariance Matrix:\n", eigenvalues_D)
print("Eigenvectors of Covariance Matrix:\n", eigenvectors_D)

# Reduce D to 2 principal components
D_pca = np.dot(D_standardized, eigenvectors_D[:, :2])
print("D reduced to 2 principal components:\n", D_pca)